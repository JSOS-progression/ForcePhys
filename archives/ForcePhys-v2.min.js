(function(global){

// ============================
// ForcePhys-v2 (with controls + drag + collision events)
// Requires Matter.js to be loaded beforehand.
// ============================
const ForcePhys = {};

// ===== World =====
ForcePhys.World = class {
    constructor({canvasId, gravity=1}){
        this.canvas = document.getElementById(canvasId);
        if(!this.canvas) throw new Error(`Canvas with id "${canvasId}" not found`);
        this.ctx = this.canvas.getContext('2d');

        // Matter.js setup
        this.engine = Matter.Engine.create();
        this.engine.world.gravity.y = gravity;
        this.bodies = [];

        // World boundaries (static)
        const width = this.canvas.width;
        const height = this.canvas.height;
        const thickness = 50;
        const options = { isStatic:true, label: 'ForcePhysBoundary' };

        this.floor = Matter.Bodies.rectangle(width/2, height + thickness/2, width, thickness, options);
        this.leftWall = Matter.Bodies.rectangle(-thickness/2, height/2, thickness, height, options);
        this.rightWall = Matter.Bodies.rectangle(width + thickness/2, height/2, thickness, height, options);
        this.roof = Matter.Bodies.rectangle(width/2, -thickness/2, width, thickness, options);

        Matter.World.add(this.engine.world, [this.floor, this.leftWall, this.rightWall, this.roof]);

        // Mouse / drag
        this.mouse = Matter.Mouse.create(this.canvas);
        this.mouseConstraint = Matter.MouseConstraint.create(this.engine, {
            mouse: this.mouse,
            constraint: { stiffness: 0.2, render: { visible: false } }
        });
        Matter.World.add(this.engine.world, this.mouseConstraint);

        // Controls and callbacks containers
        this._keyboardBindings = {}; // id -> config
        this._pressedKeys = {};
        this._collisionCallbacks = [];

        // Apply keyboard forces each tick
        Matter.Events.on(this.engine, 'beforeUpdate', () => {
            for (const id in this._keyboardBindings) {
                const cfg = this._keyboardBindings[id];
                const body = this.getObjectById(id);
                if(!body) continue;
                // continuous motion when key held
                if(this._pressedKeys[cfg.left])  Matter.Body.applyForce(body, body.position, { x: -cfg.forceX, y: 0 });
                if(this._pressedKeys[cfg.right]) Matter.Body.applyForce(body, body.position, { x:  cfg.forceX, y: 0 });
                if(this._pressedKeys[cfg.up])    Matter.Body.applyForce(body, body.position, { x: 0, y: -cfg.forceY });
                if(this._pressedKeys[cfg.down])  Matter.Body.applyForce(body, body.position, { x: 0, y:  cfg.forceY });
            }
        });

        // Wire keyboard listeners for press/release
        window.addEventListener('keydown', (e)=> { this._pressedKeys[e.key] = true; });
        window.addEventListener('keyup',   (e)=> { this._pressedKeys[e.key] = false; });

        // Collision event -> call user callbacks
        Matter.Events.on(this.engine, 'collisionStart', (ev) => {
            for (const pair of ev.pairs) {
                const a = pair.bodyA, b = pair.bodyB;
                const idA = a.forcePhysId || null;
                const idB = b.forcePhysId || null;
                const contact = {
                    bodyA: a,
                    bodyB: b,
                    idA, idB,
                    normal: pair.collision.normal,
                    depth: pair.collision.depth
                };
                for(const cb of this._collisionCallbacks) {
                    try { cb(contact); } catch (err) { console.error('ForcePhys collision callback error:', err); }
                }
            }
        });
    }

    add(obj){
        let body;
        const options = { restitution: obj.restitution ?? 0.7, friction: obj.friction ?? 0.1, angle: obj.angle ?? 0 };
        if(obj.type==='circle'){
            body = Matter.Bodies.circle(obj.x, obj.y, obj.r, options);
        } else if(obj.type==='rect'){
            body = Matter.Bodies.rectangle(obj.x, obj.y, obj.w, obj.h, options);
        } else if(obj.type==='poly'){
            body = Matter.Bodies.polygon(obj.x, obj.y, obj.sides, obj.s, options);
        } else {
            throw new Error('Unknown body type: ' + obj.type);
        }

        body.forcePhysId = obj.id || null;
        body.forcePhysColor = obj.color || 'black';
        body.forcePhysBorder = obj.border || null;
        body.forcePhysClass = obj.class || null;
        body.forcePhysMeta = obj.meta || null; // user data

        this.bodies.push(body);
        Matter.World.add(this.engine.world, body);

        return body;
    }

    // start simulation + render loop
    start(){
        Matter.Engine.run(this.engine);
        const ctx = this.ctx;
        const bodies = this.bodies;
        const renderLoop = () => {
            ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

            // draw bodies
            for(let b of bodies){
                ctx.fillStyle = b.forcePhysColor || 'black';
                if(b.circleRadius){
                    ctx.beginPath();
                    ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, Math.PI*2);
                    ctx.fill();
                    if(b.forcePhysBorder){
                        ctx.strokeStyle = b.forcePhysBorder.color;
                        ctx.lineWidth = b.forcePhysBorder.width;
                        ctx.stroke();
                    }
                } else {
                    const verts = b.vertices;
                    ctx.beginPath();
                    ctx.moveTo(verts[0].x, verts[0].y);
                    for(let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
                    ctx.closePath();
                    ctx.fill();
                    if(b.forcePhysBorder){
                        ctx.strokeStyle = b.forcePhysBorder.color;
                        ctx.lineWidth = b.forcePhysBorder.width;
                        ctx.stroke();
                    }
                }
            }

            // optional: draw mouse constraint anchor (when dragging)
            requestAnimationFrame(renderLoop);
        };
        renderLoop();
    }

    stop(){
        // minimal stop: clear keyboard listeners state and attempt to stop engine
        this._pressedKeys = {};
        // Note: Matter.Engine.clear / Runner usage can be added if needed
    }

    getObjectById(id){
        return this.bodies.find(b => b.forcePhysId === id);
    }

    // Keyboard control binding:
    // config: { left: 'ArrowLeft', right: 'ArrowRight', up:'ArrowUp', down:'ArrowDown', forceX: 0.002, forceY:0.004 }
    enableKeyboardControl(id, config = {}) {
        const defaultCfg = { left:'ArrowLeft', right:'ArrowRight', up:'ArrowUp', down:'ArrowDown', forceX:0.002, forceY:0.004 };
        const cfg = Object.assign({}, defaultCfg, config);
        this._keyboardBindings[id] = cfg;
    }

    // remove keyboard binding
    disableKeyboardControl(id) {
        delete this._keyboardBindings[id];
    }

    // Apply an instantaneous impulse to a body (useful on keypress)
    applyImpulseTo(id, impulseVec) {
        const b = this.getObjectById(id);
        if(!b) return;
        Matter.Body.applyForce(b, b.position, impulseVec);
    }

    // Mouse dragging is already enabled via MouseConstraint in constructor.
    // You can toggle the mouse constraint:
    enableMouseDrag() {
        if (!this.mouseConstraint) {
            this.mouse = Matter.Mouse.create(this.canvas);
            this.mouseConstraint = Matter.MouseConstraint.create(this.engine, {
                mouse: this.mouse,
                constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Matter.World.add(this.engine.world, this.mouseConstraint);
        }
    }
    disableMouseDrag() {
        if (this.mouseConstraint) {
            Matter.World.remove(this.engine.world, this.mouseConstraint);
            this.mouseConstraint = null;
            this.mouse = null;
        }
    }

    // Collision callbacks: callback(contact) where contact has idA, idB, bodyA, bodyB, normal, depth
    onCollision(callback) {
        if (typeof callback === 'function') this._collisionCallbacks.push(callback);
    }

    // remove a collision callback reference if needed
    offCollision(callback) {
        this._collisionCallbacks = this._collisionCallbacks.filter(cb => cb !== callback);
    }

}; // end World

// ===== Objects =====
ForcePhys.Circle = class {
    constructor({x,y,r,color='black',id=null,border=null, restitution, friction, className, meta}){
        this.type='circle';
        this.x=x; this.y=y; this.r=r;
        this.color=color; this.id=id; this.border=border;
        this.restitution = restitution; this.friction = friction;
        this.class = className; this.meta = meta;
    }
};

ForcePhys.Rect = class {
    constructor({x,y,w,h,color='black',id=null,border=null, restitution, friction, className, meta}){
        this.type='rect';
        this.x=x; this.y=y; this.w=w; this.h=h;
        this.color=color; this.id=id; this.border=border;
        this.restitution = restitution; this.friction = friction;
        this.class = className; this.meta = meta;
    }
};

ForcePhys.Poly = class {
    constructor({x,y,s,sides=3,color='black',id=null,border=null, restitution, friction, className, meta}){
        this.type='poly';
        this.x=x; this.y=y; this.s=s; this.sides=sides;
        this.color=color; this.id=id; this.border=border;
        this.restitution = restitution; this.friction = friction;
        this.class = className; this.meta = meta;
    }
};

// ===== Style API =====
ForcePhys.Style = function(world, styles){
    for(let key in styles){
        const body = world.getObjectById(key);
        if(!body) continue;
        const style = styles[key];
        if(style.color) body.forcePhysColor = style.color;
        if(style.border) body.forcePhysBorder = style.border;
    }
};

global.ForcePhys = ForcePhys;

})(window);
