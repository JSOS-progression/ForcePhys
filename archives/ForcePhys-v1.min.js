(function(global) {

    const ForcePhys = {};

    // ==== World ====
    ForcePhys.World = class {
        constructor({ canvasId, gravity = 0.5 }) {
            this.gravity = gravity;
            this.objects = [];
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.running = false;
        }

        add(obj) { this.objects.push(obj); }
        getObjectById(id) { return this.objects.find(o => o.id === id); }
        getObjectsByClass(className) { return this.objects.filter(o => o.class === className); }

        update() {
            for (let obj of this.objects) {
                obj.vy += this.gravity;
                obj.x += obj.vx;
                obj.y += obj.vy;

                const bottom = obj.type === 'circle' ? obj.r : obj.h;
                if (obj.y + bottom > this.canvas.height) { obj.y = this.canvas.height - bottom; obj.vy *= -0.7; }
                const right = obj.type === 'circle' ? obj.r : obj.w;
                if (obj.x < 0 || obj.x + right > this.canvas.width) obj.vx *= -0.7;
            }
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (let obj of this.objects) {
                this.ctx.fillStyle = obj.color || 'black';
                if (obj.border) { this.ctx.strokeStyle = obj.border.color; this.ctx.lineWidth = obj.border.width; }
                if (obj.type === 'circle') {
                    this.ctx.beginPath();
                    this.ctx.arc(obj.x, obj.y, obj.r, 0, Math.PI*2);
                    this.ctx.fill();
                    if (obj.border) this.ctx.stroke();
                } else if (obj.type === 'rect') {
                    this.ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
                    if (obj.border) this.ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
                }
            }
        }

        step() { this.update(); this.draw(); if (this.running) requestAnimationFrame(() => this.step()); }
        start() { this.running = true; this.step(); }
        stop() { this.running = false; }
    };

    // ==== Circle ====
    ForcePhys.Circle = class {
        constructor({ x, y, r, vx=0, vy=0, color='black', id=null, className=null, border=null }) {
            this.type='circle'; this.x=x; this.y=y; this.r=r;
            this.vx=vx; this.vy=vy; this.color=color;
            this.id=id; this.class=className; this.border=border;
        }
    };

    // ==== Rect ====
    ForcePhys.Rect = class {
        constructor({ x, y, w, h, vx=0, vy=0, color='black', id=null, className=null, border=null }) {
            this.type='rect'; this.x=x; this.y=y; this.w=w; this.h=h;
            this.vx=vx; this.vy=vy; this.color=color;
            this.id=id; this.class=className; this.border=border;
        }
    };

    // ==== Style ====
    ForcePhys.Style = function(world, styles) {
        for (let key in styles) {
            const obj = world.getObjectById(key);
            if (!obj) continue;
            const style = styles[key];
            if (style.color) obj.color = style.color;
            if (style.border) obj.border = style.border;
            if (style.class) obj.class = style.class;
        }
    };

    // Expose globally
    global.ForcePhys = ForcePhys;

})(window);
