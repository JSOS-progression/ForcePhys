/* ForcePhys v3.0 - single-file wrapper
   - Dynamically loads matter-js if needed
   - Exposes window.ForcePhys
   - Features: per-body bounciness/friction/density, gravityScale, draggable:false enforcement,
     collision events, mouse drag, keyboard helpers, style API, debug toggle.
*/
(function(global){

const DEFAULT_MATTER_CDN = 'https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js';

function ensureMatter(next){
  if(global.Matter) return next();
  const s = document.createElement('script');
  s.src = DEFAULT_MATTER_CDN;
  s.onload = () => next();
  s.onerror = () => { throw new Error('Failed to load Matter.js from CDN'); };
  document.head.appendChild(s);
}

ensureMatter(() => {
  const Matter = global.Matter;

  const ForcePhys = {};

  // Utils
  const uid = (() => { let i=0; return (p='f')=>`${p}${++i}` })();
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // ===== World =====
  ForcePhys.World = class {
    constructor({ canvasId, gravity = 1, mouseDrag = true, debug = false, pixelRatio = 1 } = {}) {
      const canvas = document.getElementById(canvasId);
      if(!canvas) throw new Error(`ForcePhys: Canvas "${canvasId}" not found`);
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.pixelRatio = pixelRatio;

      // Matter
      this.engine = Matter.Engine.create();
      this.engine.world.gravity.y = gravity;
      this.bodies = [];           // wrappers
      this._idMap = new Map();   // id -> wrapper
      this._classMap = new Map(); // className -> Set(wrappers)
      this._collisionListeners = { start: [], end: [] };
      this._keyboardBindings = {}; // id -> cfg
      this._pressed = {};
      this._debug = debug;

      // Mouse drag
      this._mouseEnabled = mouseDrag;
      if(this._mouseEnabled) this._initMouse();

      // collision events from Matter -> user callbacks
      Matter.Events.on(this.engine, 'collisionStart', ev => this._emitCollision('start', ev));
      Matter.Events.on(this.engine, 'collisionEnd', ev => this._emitCollision('end', ev));

      // hook for continuous keyboard forces and gravityScale
      Matter.Events.on(this.engine, 'beforeUpdate', e => {
        const dt = (e.source.timing.delta || 1000/60) / 1000;
        // keyboard continuous force
        for(const id in this._keyboardBindings){
          const cfg = this._keyboardBindings[id];
          const wrapper = this.getObjectById(id);
          if(!wrapper) continue;
          const body = wrapper.matter;
          if(this._pressed[cfg.left]) Matter.Body.applyForce(body, body.position, { x: -cfg.forceX*dt, y: 0 });
          if(this._pressed[cfg.right]) Matter.Body.applyForce(body, body.position, { x:  cfg.forceX*dt, y: 0 });
          if(this._pressed[cfg.up]) Matter.Body.applyForce(body, body.position, { x: 0, y: -cfg.forceY*dt });
          if(this._pressed[cfg.down]) Matter.Body.applyForce(body, body.position, { x: 0, y:  cfg.forceY*dt });
        }
        // gravityScale: apply extra per-body force to simulate different gravity
        for(const w of this.bodies){
          const gScale = (w.gravityScale === undefined) ? 1 : w.gravityScale;
          if(gScale !== 1){
            const body = w.matter;
            const worldG = this.engine.world.gravity.y;
            // desired acceleration = worldG * gScale; current acceleration from world = worldG
            // additional acceleration = worldG * (gScale - 1)
            const aExtra = worldG * (gScale - 1);
            // F = m * a; convert to impulse per tick: F*dt -> approximate small force
            const addF = body.mass * aExtra * dt;
            Matter.Body.applyForce(body, body.position, { x: 0, y: addF });
          }
        }
      });

      // keyboard listeners
      window.addEventListener('keydown', e => { this._pressed[e.key] = true; });
      window.addEventListener('keyup',   e => { this._pressed[e.key] = false; });

      // render loop
      this._running = false;
      this._raf = null;
      this._render = this._render.bind(this);
    }

    // ========== internal mouse setup ==========
    _initMouse(){
      this._mouse = Matter.Mouse.create(this.canvas);
      this._mouseConstraint = Matter.MouseConstraint.create(this.engine, {
        mouse: this._mouse,
        constraint: { stiffness: 0.2, render: { visible: false } }
      });
      // enforce draggable flag on startdrag
      Matter.Events.on(this._mouseConstraint, 'startdrag', e => {
        const body = e.body;
        if(body && body.forcePhys && body.forcePhys.draggable === false){
          // cancel dragging by clearing the constraint body
          this._mouseConstraint.constraint.bodyB = null;
        }
      });
      Matter.World.add(this.engine.world, this._mouseConstraint);
    }

    // ========== add object ==========
    add(spec){
      // spec: wrapper-friendly options
      const wrapper = {};
      wrapper.type = spec.type || spec.constructor && spec.constructor.name.toLowerCase() || 'rect';
      wrapper.id = spec.id || uid('obj');
      wrapper.class = spec.class || spec.className || null;
      wrapper.color = spec.color || spec.fill || '#666';
      wrapper.border = spec.border || null;
      wrapper.bounciness = (spec.bounciness !== undefined) ? spec.bounciness : (spec.restitution !== undefined ? spec.restitution : 0);
      wrapper.friction = (spec.friction !== undefined) ? spec.friction : 0.1;
      wrapper.density = (spec.density !== undefined) ? spec.density : undefined;
      wrapper.gravityScale = (spec.gravityScale !== undefined) ? spec.gravityScale : 1;
      wrapper.draggable = (spec.draggable !== undefined) ? spec.draggable : true;
      wrapper.static = !!spec.static;
      wrapper.meta = spec.meta || null;

      // store geometric props for drawing convenience
      if(wrapper.type === 'circle'){
        wrapper.x = spec.x; wrapper.y = spec.y; wrapper.r = spec.r;
      } else if(wrapper.type === 'rect'){
        wrapper.x = spec.x; wrapper.y = spec.y; wrapper.w = spec.w; wrapper.h = spec.h;
      } else if(wrapper.type === 'poly'){
        wrapper.x = spec.x; wrapper.y = spec.y; wrapper.s = spec.s; wrapper.sides = Math.max(3, spec.sides || 3);
      }

      // create Matter body
      const matterOpts = {
        restitution: wrapper.bounciness,
        friction: wrapper.friction,
        isStatic: wrapper.static,
      };
      if(wrapper.density !== undefined) matterOpts.density = wrapper.density;

      let body;
      if(wrapper.type === 'circle'){
        body = Matter.Bodies.circle(wrapper.x, wrapper.y, wrapper.r, matterOpts);
      } else if(wrapper.type === 'rect'){
        // Matter rect takes width/height; create centered rect
        body = Matter.Bodies.rectangle(wrapper.x, wrapper.y, wrapper.w, wrapper.h, matterOpts);
      } else if(wrapper.type === 'poly'){
        body = Matter.Bodies.polygon(wrapper.x, wrapper.y, wrapper.sides, wrapper.s, matterOpts);
      } else {
        throw new Error('ForcePhys: unknown type ' + wrapper.type);
      }

      // attach link & metadata
      body.forcePhys = wrapper; // backref
      body.forcePhys.id = wrapper.id;
      body.forcePhys.draggable = wrapper.draggable;
      body.forcePhys.color = wrapper.color;
      body.forcePhys.border = wrapper.border;
      body.forcePhys.class = wrapper.class;
      body.forcePhys.meta = wrapper.meta;
      wrapper.matter = body;

      // expose useful getters on wrapper for vx/vy
      Object.defineProperty(wrapper, 'vx', { get: () => wrapper.matter.velocity.x });
      Object.defineProperty(wrapper, 'vy', { get: () => wrapper.matter.velocity.y });

      // track maps
      this.bodies.push(wrapper);
      this._idMap.set(wrapper.id, wrapper);
      if(wrapper.class){
        if(!this._classMap.has(wrapper.class)) this._classMap.set(wrapper.class, new Set());
        this._classMap.get(wrapper.class).add(wrapper);
      }

      Matter.World.add(this.engine.world, body);
      return wrapper;
    }

    // ========== helpers ==========
    getObjectById(id){ return this._idMap.get(id) || null; }
    getObjectsByClass(cls){ return Array.from(this._classMap.get(cls) || []); }

    applyForce(id, fx, fy){ // instantaneous force vector (not impulse)
      const w = this.getObjectById(id); if(!w) return;
      Matter.Body.applyForce(w.matter, w.matter.position, { x: fx, y: fy });
    }

    setVelocity(id, vx, vy){
      const w = this.getObjectById(id); if(!w) return;
      Matter.Body.setVelocity(w.matter, { x: vx, y: vy });
    }

    getVelocity(id){
      const w = this.getObjectById(id); if(!w) return null;
      return { x: w.matter.velocity.x, y: w.matter.velocity.y };
    }

    // keyboard control: continuous force while keys held
    enableKeyboardControl(id, cfg = {}){
      const def = { left:'ArrowLeft', right:'ArrowRight', up:'ArrowUp', down:'ArrowDown', forceX:0.002, forceY:0.004 };
      this._keyboardBindings[id] = Object.assign({}, def, cfg);
    }
    disableKeyboardControl(id){ delete this._keyboardBindings[id]; }

    // on/off collision events
    on(eventName, cb){
      if(eventName === 'collisionStart' || eventName === 'collisionstart') this._collisionListeners.start.push(cb);
      else if(eventName === 'collisionEnd' || eventName === 'collisionend') this._collisionListeners.end.push(cb);
      else throw new Error('Unknown event: ' + eventName);
    }
    off(eventName, cb){
      const arr = (eventName.startsWith('collision') && eventName.toLowerCase().includes('start')) ? this._collisionListeners.start
                : this._collisionListeners.end;
      const i = arr.indexOf(cb); if(i>=0) arr.splice(i,1);
    }

    _emitCollision(kind, ev){
      // ev.pairs from Matter
      for(const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;
        const idA = a.forcePhys && a.forcePhys.id || null;
        const idB = b.forcePhys && b.forcePhys.id || null;
        const contact = {
          idA, idB,
          bodyA: a, bodyB: b,
          normal: pair.collision.normal,
          depth: pair.collision.depth
        };
        const listeners = (kind === 'start') ? this._collisionListeners.start : this._collisionListeners.end;
        for(const cb of listeners) {
          try { cb(contact); } catch(err){ console.error('ForcePhys collision handler error', err); }
        }
      }
    }

    // style API: change visual appearance
    staticStyle(wrapperOrId, styleObj){
      const wrapper = (typeof wrapperOrId === 'string') ? this.getObjectById(wrapperOrId) : wrapperOrId;
      if(!wrapper) return;
      if(styleObj.color) wrapper.color = styleObj.color;
      if(styleObj.border) wrapper.border = styleObj.border;
      if(styleObj.image) wrapper.image = styleObj.image; // image url (not loaded automatically)
    }

    // expose a simpler Style facade
    static Style(world, styles){
      // kept for backwards compatibility: ForcePhys.Style(world, { id: { color... } })
      for(const id in styles){
        const w = world.getObjectById(id);
        if(!w) continue;
        const s = styles[id];
        if(s.color) w.color = s.color;
        if(s.border) w.border = s.border;
      }
    }

    // toggle debug (wireframe)
    toggleDebug(v){
      this._debug = !!v;
    }

    // remove body by id
    remove(id){
      const w = this.getObjectById(id);
      if(!w) return;
      Matter.World.remove(this.engine.world, w.matter);
      this.bodies = this.bodies.filter(x => x !== w);
      this._idMap.delete(id);
      if(w.class && this._classMap.has(w.class)) this._classMap.get(w.class).delete(w);
    }

    // main render loop
    _render(){
      const ctx = this.ctx;
      const W = this.canvas.width, H = this.canvas.height;
      ctx.clearRect(0,0,W,H);

      // draw bodies
      for(const w of this.bodies){
        const b = w.matter;
        // draw fill
        if(w.image){
          // optional: draw image if loaded; for simplicity we ignore loading here
        }
        ctx.save();
        ctx.translate(b.position.x, b.position.y);
        ctx.rotate(b.angle);

        ctx.fillStyle = w.color || '#666';
        ctx.strokeStyle = (w.border && w.border.color) || '#000';
        ctx.lineWidth = (w.border && w.border.width) || 0;

        if(b.circleRadius){
          ctx.beginPath();
          ctx.arc(0,0,b.circleRadius,0,Math.PI*2);
          ctx.fill();
          if(w.border) ctx.stroke();
        } else {
          const verts = b.vertices;
          ctx.beginPath();
          ctx.moveTo(verts[0].x - b.position.x, verts[0].y - b.position.y);
          for(let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x - b.position.x, verts[i].y - b.position.y);
          ctx.closePath();
          ctx.fill();
          if(w.border) ctx.stroke();
        }
        ctx.restore();

        if(this._debug){
          // wireframe overlay (simple)
          ctx.save();
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          if(b.circleRadius){
            ctx.beginPath();
            ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, Math.PI*2);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(b.vertices[0].x, b.vertices[0].y);
            for(let i=1;i<b.vertices.length;i++) ctx.lineTo(b.vertices[i].x, b.vertices[i].y);
            ctx.closePath();
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      // update physics
      Matter.Engine.update(this.engine, 1000/60);

      if(this._running) this._raf = requestAnimationFrame(() => this._render());
    }

    start(){
      if(this._running) return;
      this._running = true;
      Matter.Engine.run(this.engine);
      this._raf = requestAnimationFrame(() => this._render());
    }

    stop(){
      this._running = false;
      if(this._raf) cancelAnimationFrame(this._raf);
      // note: not destroying engine
    }

    // utility: return mouse position relative to canvas
    screenToWorld(evt){
      const rect = this.canvas.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (this.canvas.width / rect.width);
      const y = (evt.clientY - rect.top) * (this.canvas.height / rect.height);
      return { x, y };
    }

    // optional helper to get body at location (search wrappers)
    getBodyAt(x,y){
      // simple point-in-poly / point-in-circle test using matter's query
      const found = Matter.Query.point(Matter.Composite.allBodies(this.engine.world), { x, y });
      if(found.length) return found[0].forcePhys ? found[0].forcePhys : null;
      return null;
    }
  }; // end World

  // Backwards-compatible object constructors (thin wrappers)
  ForcePhys.Circle = function(opts){
    opts = Object.assign({}, opts); opts.type = 'circle'; return opts;
  };
  ForcePhys.Rect = function(opts){
    opts = Object.assign({}, opts); opts.type = 'rect'; return opts;
  };
  ForcePhys.Poly = function(opts){
    opts = Object.assign({}, opts); opts.type = 'poly'; return opts;
  };

  // Keep a compatibility Style function (world-scoped)
  ForcePhys.Style = ForcePhys.World.staticStyle || ForcePhys.World.Style || ((...a)=>{});

  // Expose
  global.ForcePhys = ForcePhys;

}); // end ensureMatter
})(window);
